<!DOCTYPE html>
<!-- Generated by pkgdown: do not edit by hand --><html><head><meta http-equiv="Content-Type" content="text/html; charset=UTF-8"><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0"><title>ptstem: Stemming Algorithms for the Portuguese Language. ptstem</title><!-- jquery --><script src="https://code.jquery.com/jquery-3.1.0.min.js" integrity="sha384-nrOSfDHtoPMzJHjVTdCopGqIqeYETSXhZDFyniQ8ZHcVy08QesyHcnOUpMpqnmWq" crossorigin="anonymous"></script><!-- Bootstrap --><link href="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet" integrity="sha384-BVYiiSIFeK1dGmJRAkycuHAHRg32OmUcww7on3RYdg4Va+PmSTsz/K68vbdEjh4u" crossorigin="anonymous"><script src="https://maxcdn.bootstrapcdn.com/bootstrap/3.3.7/js/bootstrap.min.js" integrity="sha384-Tc5IQib027qvyjSMfHjOMaLkfuWVxZxUPnCJA7l2mCWNIpG9mGCD8wGNIcPD7Txa" crossorigin="anonymous"></script><!-- Font Awesome icons --><link href="https://maxcdn.bootstrapcdn.com/font-awesome/4.6.3/css/font-awesome.min.css" rel="stylesheet" integrity="sha384-T8Gy5hrqNKT+hzMclPo118YTQO6cYprQmhrYwIiQ/3axmI1hQomh7Ud2hPOy8SP1" crossorigin="anonymous"><!-- pkgdown --><link href="../pkgdown.css" rel="stylesheet"><script src="../pkgdown.js"></script><!-- mathjax --><script src="https://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script><!--[if lt IE 9]>
<script src="https://oss.maxcdn.com/html5shiv/3.7.3/html5shiv.min.js"></script>
<script src="https://oss.maxcdn.com/respond/1.4.2/respond.min.js"></script>
<![endif]--></head><body>
    <div class="container">
      <header><div class="navbar navbar-default  navbar-fixed-top" role="navigation">
  <div class="container">
    <div class="navbar-header">
      <button type="button" class="navbar-toggle collapsed" data-toggle="collapse" data-target="#navbar">
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
        <span class="icon-bar"></span>
      </button>
      <a class="navbar-brand" href="../index.html">ptstem</a>
    </div>
    <div id="navbar" class="navbar-collapse collapse">
      <ul class="nav navbar-nav"><li>
  <a href="../index.html">Home</a>
</li>
<li>
  <a href="../reference/index.html">Reference</a>
</li>
<li>
  <a href="../articles/index.html">Articles</a>
</li>
<li>
  <a href="../news/index.html">News</a>
</li>
      </ul><ul class="nav navbar-nav navbar-right"><li>
  <a href="https://github.com/dfalbel/ptstem">
    <span class="fa fa-github fa-lg"></span>
     
  </a>
</li>
      </ul></div><!--/.nav-collapse -->
  </div><!--/.container -->
</div><!--/.navbar -->
      
      </header><div class="row">
  <div class="col-md-9">
    <div class="page-header toc-ignore">
      <h1>ptstem: Stemming Algorithms for the Portuguese Language</h1>
                        <h4 class="author">Daniel Falbel</h4>
            
            <h4 class="date">2016-10-06</h4>
          </div>

    
    
<blockquote>
<p>In linguistic morphology and information retrieval, stemming is the process of reducing inflected (or sometimes derived) words to their word stem, base or root form&mdash;generally a written word form. The stem need not be identical to the morphological root of the word; it is usually sufficient that related words map to the same stem, even if this stem is not in itself a valid root. Algorithms for stemming have been studied in computer science since the 1960s. Many search engines treat words with the same stem as synonyms as a kind of query expansion, a process called conflation.</p>
</blockquote>
<p>From <a href="https://en.wikipedia.org/wiki/Stemming">Wikipedia</a></p>
<p>This paragraph gives a nice explanation of what <em>stemming</em> is. Much of academic work on stemming was focused on English Language and it&rsquo;s somewhat hard to find stemming algorithms for other languages. <code>ptstem</code> tries to fix this, by providing a comprehensive interface for Portuguese Language stemming algorithms.</p>
<p>The implemented algorithms are:</p>
<ul><li><strong>rslp</strong>: <a href="http://doi.ieeecomputersociety.org/10.1109/SPIRE.2001.10024">RSLP</a> is a simple and effective suffix-stripping algorithm for Portuguese. Implemented in <code>R</code> in the <a href="https://CRAN.R-project.org/package=rslp"><code>rslp</code></a> package.</li>
<li><strong>hunspell</strong>: <a href="https://hunspell.github.io/">Hunspell</a> is the spell checker of LibreOffice, OpenOffice.org, Mozilla Firefox 3 &amp; Thunderbird, Google Chrome, and it is also used by proprietary software packages, like Mac OS X, InDesign, memoQ, Opera and SDL Trados. It&rsquo;s implemented in <code>R</code> in the <a href="https://CRAN.R-project.org/package=hunspell"><code>hunspell</code></a> package.</li>
<li><strong>porter</strong>: The <a href="https://tartarus.org/martin/PorterStemmer/">Porter stemming algorithm</a> (or &lsquo;Porter stemmer&rsquo;) is a process for removing the commoner morphological and inflexional endings from words. In <code>R</code> it&rsquo;s implemented in the <a href="https://CRAN.R-project.org/package=SnowballC"><code>SnowballC</code></a> package.</li>
</ul><div id="stemming" class="section level2">
<h2>Stemming</h2>
<p><code>ptstem</code> has only one important function that is called <code>ptstem</code>. You can easily stem a text by passing it to <code>ptstem</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw">library</span>(ptstem)</code></pre></div>
<div id="example-1" class="section level3">
<h3>Example 1</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">text &lt;-<span class="st"> "Em morfologia lingu&iacute;stica e recupera&ccedil;&atilde;o de informa&ccedil;&atilde;o a stemiza&ccedil;&atilde;o (do ingl&ecirc;s, stemming) &eacute;</span>
<span class="st">o processo de reduzir palavras flexionadas (ou &agrave;s vezes derivadas) ao seu tronco (stem), base ou</span>
<span class="st">raiz, geralmente uma forma da palavra escrita. O tronco n&atilde;o precisa ser id&ecirc;ntico &agrave; raiz morfol&oacute;gica</span>
<span class="st">da palavra; ele geralmente &eacute; suficiente que palavras relacionadas sejam mapeadas para o mesmo</span>
<span class="st">tronco, mesmo se este tronco n&atilde;o for ele pr&oacute;prio uma raiz v&aacute;lida. O estudo de algoritmos para</span>
<span class="st">stemiza&ccedil;&atilde;o tem sido realizado em ci&ecirc;ncia da computa&ccedil;&atilde;o desde a d&eacute;cada de 60. V&aacute;rios motores de</span>
<span class="st">buscas tratam palavras com o mesmo tronco como sin&ocirc;nimos como um tipo de expans&atilde;o de consulta, em</span>
<span class="st">um processo de combina&ccedil;&atilde;o."</span></code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/ptstem_words.html">ptstem</a></span>(text)</code></pre></div>
<pre><code>## [1] "Em morfologia lingu&iacute;stica e recupera&ccedil;&atilde;o de informa&ccedil;&atilde;o a stemiza&ccedil;&atilde;o (do ingl&ecirc;s, stemming) &eacute;\no processo de reduzir palavras flexionadas (ou &agrave;s vezes derivadas) ao seu tronco (stem), base ou\nraiz, geralmente uma forma da palavras escrita. O tronco n&atilde;o precisa ser id&ecirc;ntico &agrave; raiz morfologia\nda palavras; ele geralmente &eacute; suficiente que palavras relacionadas sejam mapeadas para o mesmo\ntronco, mesmo se este tronco n&atilde;o for ele pr&oacute;prio uma raiz v&aacute;lida. O estudo de algoritmos para\nstemiza&ccedil;&atilde;o tem sido realizado em ci&ecirc;ncia da computa&ccedil;&atilde;o desde a d&eacute;cada de 60. V&aacute;rios motores de\nbuscas tratam palavras com o mesmo tronco com sin&ocirc;nimos com um tipo de expans&atilde;o de consulta, em\num processo de combina&ccedil;&atilde;o."</code></pre>
<p>By default <code>ptstem</code> uses the <em>rslp</em> algorithm to stem, and it complete stems with the most frequent word in the text (This is explained later). Is this example it&rsquo;s a little hard to see improvements with stemming, because the text doesn&rsquo;t contain many words with the same root. Let&rsquo;s look at a more simple example.</p>
</div>
<div id="example-2" class="section level3">
<h3>Example 2</h3>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">text &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">"avi&atilde;o"</span>, <span class="st">"avi&otilde;es"</span>, <span class="st">"avia&ccedil;&atilde;o"</span>, <span class="st">"via&ccedil;&atilde;o"</span>, <span class="st">"aves"</span>, <span class="st">"bal&atilde;o"</span>, <span class="st">"bal&otilde;es"</span>)
<span class="kw"><a href="../reference/ptstem_words.html">ptstem</a></span>(text)</code></pre></div>
<pre><code>## [1] "avi&atilde;o"  "avi&atilde;o"  "avi&atilde;o"  "via&ccedil;&atilde;o" "aves"   "bal&atilde;o"  "bal&atilde;o"</code></pre>
<p>You can return the suffix stripped words (without completion) by setting the argument <code>complete = FALSE</code>.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/ptstem_words.html">ptstem</a></span>(text, <span class="dt">complete =</span> <span class="ot">FALSE</span>)</code></pre></div>
<pre><code>## [1] "avi"  "avi"  "avi"  "viac" "ave"  "bal"  "bal"</code></pre>
<p>You can also change the algorithm used to stem by setting the <code>algorithm</code> argument.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/ptstem_words.html">ptstem</a></span>(text, <span class="dt">algorithm =</span> <span class="st">"hunspell"</span>, <span class="dt">complete =</span> <span class="ot">FALSE</span>)</code></pre></div>
<pre><code>## [1] "avi&atilde;o"  "avi&atilde;o"  "via&ccedil;&atilde;o" "via&ccedil;&atilde;o" "ave"    "bal&atilde;o"  "bal&atilde;o"</code></pre>
<p>The hunspell stemmer is not a suffix-stripping algorithm, so it can find related words that has the same sufffix. It happened here with the word &ldquo;avia&ccedil;&atilde;o&rdquo; that was related to &ldquo;via&ccedil;&atilde;o&rdquo; instead of &ldquo;avi&atilde;o&rdquo; and &ldquo;avi&otilde;es&rdquo;. Also you can see that hunspell is returning valid words, even with <code>complete = FALSE</code>, but it does not necessarily returns words that appear in the text, see:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/ptstem_words.html">ptstem</a></span>(<span class="st">"avi&otilde;es"</span>, <span class="st">"hunspell"</span>, <span class="dt">complete =</span> <span class="ot">FALSE</span>)</code></pre></div>
<pre><code>## [1] "avi&atilde;o"</code></pre>
<p>To use the Porter stemmer, simply tweak the <code>algorithm</code> argument again.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/ptstem_words.html">ptstem</a></span>(text, <span class="dt">algorithm =</span> <span class="st">"porter"</span>, <span class="dt">complete =</span> <span class="ot">FALSE</span>)</code></pre></div>
<pre><code>## [1] "avi&atilde;"   "avi&otilde;"   "avia&ccedil;&atilde;" "via&ccedil;&atilde;"  "aves"   "bal&atilde;"   "bal&otilde;"</code></pre>
<p>As Porter stemmer, is a general algorithm, it has some problems when detecting irregular forms of words. In this example, the stemming didn&rsquo;t relate any words, if you hadn&rsquo;t used the <code>complete = FALSE</code> argument, you wouldn&rsquo;t have noticed any difference between the input and the output vectors.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/ptstem_words.html">ptstem</a></span>(text, <span class="dt">algorithm =</span> <span class="st">"porter"</span>)</code></pre></div>
<pre><code>## [1] "avi&atilde;o"   "avi&otilde;es"  "avia&ccedil;&atilde;o" "via&ccedil;&atilde;o"  "aves"    "bal&atilde;o"   "bal&otilde;es"</code></pre>
</div>
<div id="example-3" class="section level3">
<h3>Example 3</h3>
<p><code>ptstem</code> has two other arguments that can be used to ignore words in stemming.</p>
<ul><li><code>n_char</code>: minimum number of characters of words to be stemmed</li>
<li><code>ignore</code>: vector of words and regex&rsquo;s to igore</li>
</ul><p>Sometimes you have some words in a text that you don&rsquo;t want to stem, like proper names or words in other languages and it&rsquo;s usefull to ignore them. Sometimes you also have very small words, that if stemmed they loose their meaning, the <code>rslp</code> algorithm has some rules about words lenghts, but <code>hunspell</code> does not. That&rsquo;s why <code>n_char</code> argument is available.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r">text &lt;-<span class="st"> </span><span class="kw">c</span>(<span class="st">"obama"</span>, <span class="st">"gostei"</span>, <span class="st">"gostou"</span>, <span class="st">"gostamos"</span>, <span class="st">"&eacute;"</span>, <span class="st">"e"</span>)</code></pre></div>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/ptstem_words.html">ptstem</a></span>(text, <span class="dt">complete =</span> <span class="ot">FALSE</span>)</code></pre></div>
<pre><code>## [1] "obam" "gost" "gost" "gost" "&eacute;"    "e"</code></pre>
<p>Here <code>rslp</code> stemmed &ldquo;obama&rdquo; to &ldquo;obam&rdquo; and &ldquo;firmware&rdquo; to &ldquo;firmw&rdquo;. You can choose to not stem theese words by setting the <code>ignore</code> parameter.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/ptstem_words.html">ptstem</a></span>(text, <span class="dt">complete =</span> <span class="ot">FALSE</span>, <span class="dt">ignore =</span> <span class="kw">c</span>(<span class="st">"obama"</span>))</code></pre></div>
<pre><code>## [1] "obama" "gost"  "gost"  "gost"  "&eacute;"     "e"</code></pre>
<p>By default, <code>ptstem</code> does not stem words with less then three characters. If you set for at least 1 characters.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/ptstem_words.html">ptstem</a></span>(text, <span class="dt">complete =</span> <span class="ot">FALSE</span>, <span class="dt">n_char =</span> <span class="dv">1</span>)</code></pre></div>
<pre><code>## [1] "obam" "gost" "gost" "gost" "e"    "e"</code></pre>
<p>You can see that &ldquo;e&rdquo; and &ldquo;&eacute;&rdquo; were united. It&rsquo;s also possible to ignore regex&rsquo;s, using the <code>ignore</code> argument.</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/ptstem_words.html">ptstem</a></span>(text, <span class="dt">complete =</span> <span class="ot">FALSE</span>, <span class="dt">ignore =</span> <span class="kw">c</span>(<span class="st">"go."</span>))</code></pre></div>
<pre><code>## [1] "obam"     "gostei"   "gostou"   "gostamos" "&eacute;"        "e"</code></pre>
<p>This doesn&rsquo;t stem words that start with &ldquo;go&rdquo;.</p>
</div>
</div>
<div id="performance" class="section level2">
<h2>Performance</h2>
<p>The goal of stemming algorithms is to group related words and to separate unrelated words. With this in mind, you can talk about two kinds of possible errors when stemming:</p>
<ul><li>Understemming: Related words were not grouped because you didn&rsquo;t stem enought.</li>
<li>Overstemming: Unrelated words were grouped because you removed a large part of the word when stemming.</li>
</ul><p>To measure these errors the function <code>performance</code> was implemented. It returns a <code>data.frame</code> with 3 columns. The name of the stemmer and 2 metrics:</p>
<ul><li>UI: the undersampling index. It&rsquo;s the proportion of related words that were not grouped.</li>
<li>OI: the overstemming index. It&rsquo;s the proportion of unrelated words that were grouped.</li>
</ul><p>Remember that OI is 0 if you don&rsquo;t stem. So I think the true objective of a stemming algorithm is to reduce UI without augmenting OI too much.</p>
<p><code>ptstem</code> package provides a dataset of grouped words for the portuguese language (found in this <a href="http://www.inf.ufrgs.br/~fnflores/paice_tool/">link</a>). It&rsquo;s in this dataset that <code>performance</code> function calculates the metrics described above.</p>
<p>See results:</p>
<div class="sourceCode"><pre class="sourceCode r"><code class="sourceCode r"><span class="kw"><a href="../reference/performance.html">performance</a></span>()</code></pre></div>
<pre><code>##                 .id         UI         OI
## 1              rslp 0.08540752 0.04929234
## 2          hunspell 0.12835530 0.03221083
## 3            porter 0.13958028 0.03221083
## 4 modified-hunspell 0.05466081 0.06295754</code></pre>
<p>This is not the only approach for measuring performance of the those algorithms. The article <a href="http://dx.doi.org/10.1016/j.ipm.2016.03.004"><em>Assessing the impact of Stemming Accuracy on Information Retrieval &ndash; A multilingual perspective</em></a> describes various ways to analyse stemming performance.</p>
</div>
  </div>

  <div class="col-md-3 hidden-xs">
        <div id="tocnav">
      <h2>Contents</h2>
      <ul class="nav nav-pills nav-stacked"><li><a href="#stemming">Stemming</a></li>
      <li><a href="#performance">Performance</a></li>
      </ul></div>
      </div>

</div>


      <footer><p>Built by <a href="http://hadley.github.io/pkgdown/">pkgdown</a>. Styled with <a href="http://getbootstrap.com">Bootstrap 3</a>.</p>
      </footer></div>

  </body></html>
